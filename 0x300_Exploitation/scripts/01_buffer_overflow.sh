# 0x320 Buffer Overflows

# Buffer overflow vulnerabilities have been around since the early days of
# computers and still exist today.

# If a programmer wants to put 10 bytes of data into a buffer that had only
# been allocated 8 bytes of space, that type of action is allowed,
# even though it will most likely cause the program to crash.

# This is known as a `buffer overrun' or 'buffer overflow'.
# Here is an example (page 119).

$ gcc -o overflow_example overflow_example.c
$ ./overflow_example 'AAAAAAA'
#[BEFORE] buffer_two is at 0x7ffeed5b65a8 and contains 'two'
#[BEFORE] buffer_one is at 0x7ffeed5b65b0 and contains 'one'
#[BEFORE] value is at 0x7ffeed5b6594 and is (0x00000005)
#
#[STRCPY] copying 7 bytes into buffer_two
#
#[AFTER] buffer_two is at 0x7ffeed5b65a8 and contains 'AAAAAAA'
#[AFTER] buffer_one is at 0x7ffeed5b65b0 and contains 'one'
#[AFTER] value is at 0x7ffeed5b6594 and is (0x00000005)

$ ./overflow_example 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
#[BEFORE] buffer_two is at 0x7ffee0440598 and contains 'two'
#[BEFORE] buffer_one is at 0x7ffee04405a0 and contains 'one'
#[BEFORE] value is at 0x7ffee0440584 and is (0x00000005)
#
#[STRCPY] copying 11 bytes into buffer_two
#
#Abort trap: 6  # Overflow happened!


# Stack-Based Buffer Overflow Vulnerabilities

# The above example works by corrupting memory to control execution flow.
# Let's see `auth_overflow.c` examples that demonstrates this concept (page 124).

# Use the `-g` option when you do compile it, though, since we'll be debugging this later.
$ gcc -g -o auth_overflow auth_overflow.c

$ ./auth_overflow
#Usage: ./auth_overflow <password>

# We success!
$ ./auth_overflow brilling
#-=-=-=-=-=-=-=-=-=-=-
#       Access Granted.
#-=-=-=-=-=-=-=-=-=-=-

# We fail... because the value of `password_buffer` is different to the answer.
$ ./auth_overflow test
#Access Denied.

# What happens??!
$ ./auth_overflow AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
#*** stack smashing detected ***: ./auth_overflow terminated
#Aborted (core dumped)

# This happen occurs because `stack_overflow`!!!
# Let's check more details using GDB debugger.
$ gdb -q ./auth_overflow

$ (gdb) list 1
#1	#include <stdio.h>
#2	#include <stdlib.h>
#3	#include <string.h>
#4
#5	int check_authentication(char *password) {
#6	  int auth_flag = 0;
#7	  char password_buffer[16];
#8
#9	  strcpy(password_buffer, password);
#10
$ (gdb)
#11	  if(strcmp(password_buffer, "brilling") == 0)
#12	    auth_flag = 1;
#13	  if(strcmp(password_buffer, "outgrabe") == 0)
#14	    auth_flag = 1;
#15
#16	  return auth_flag;
#17	}
#18
#19	int main(int argc, char *argv[]) {
#20	  if(argc < 2) {

$ (gdb) break 9
#Breakpoint 1 at 0x4006d8: file auth_overflow.c, line 9.
$ (gdb) break 16
#Breakpoint 2 at 0x400723: file auth_overflow.c, line 16.

$ (gdb) run AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
#Starting program: /home/daehakim/Desktop/Research/hacking/0x300_Exploitation/auth_overflow AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

$ (gdb) x/s password_buffer
#0x7fffffffe210:	"\001"

$ (gdb) x/x &auth_flag
#0x7fffffffe20c:	0x00

$ (gdb) print 0x7fffffffe20c - 0x7fffffffe210
#$1 = -4

$ (gdb) x/16xw password_buffer
#0x7fffffffe210:	0x00000001	0x00000000	0x0040080d	0x00000000
#0x7fffffffe220:	0x00000000	0x00000000	0x96406d00	0xf5bc49cc
#0x7fffffffe230:	0xffffe250	0x00007fff	0x00400787	0x00000000
#0x7fffffffe240:	0xffffe338	0x00007fff	0x00000000	0x00000002

$ (gdb) continue
#Continuing.
#
#Breakpoint 2, check_authentication (password=0x7fffffffe60f 'A' <repeats 30 times>) at auth_overflow.c:16
#16	  return auth_flag;
$ (gdb) x/s password_buffer
#0x7fffffffe210:	'A' <repeats 30 times>

$ (gdb) x/x &auth_flag
#0x7fffffffe20c:	0x00
$ (gdb) x/16xw password_buffer
#0x7fffffffe210:	0x41414141	0x41414141	0x41414141	0x41414141
#0x7fffffffe220:	0x41414141	0x41414141	0x41414141	0xf5004141
#0x7fffffffe230:	0xffffe250	0x00007fff	0x00400787	0x00000000
#0x7fffffffe240:	0xffffe338	0x00007fff	0x00000000	0x00000002

# auth_flag value has `0`.

$ (gdb) x/dw &auth_flag
#0x7fffffffe20c:	0

# Originally, the result will show `Access Denied.`

$ (gdb) continue
#Continuing.
#*** stack smashing detected ***: /home/daehakim/Desktop/Research/hacking/0x300_Exploitation/auth_overflow terminated
#
#Program received signal SIGABRT, Aborted.
#0x00007ffff7a42428 in __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:54
#54	../sysdeps/unix/sysv/linux/raise.c: No such file or directory.

# That's why `stack_overflow` error happened!!

# In this example, the `auth_flag` variable is the execution control point,
# since overwriting this value is the source of the control.

# But this is a very contrived example that depends on memory layout of the variables. 
# In auth_overflow2.c, the variables are declared in reverse order.
$ gcc -g -o auth_overflow2 auth_overflow2.c
$ gdb -q ./auth_overflow2

